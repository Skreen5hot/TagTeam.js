<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>IEE Test Corpus Validation</title>
  <style>
    body { font-family: monospace; padding: 20px; background: #1e1e1e; color: #d4d4d4; }
    h1 { color: #4ec9b0; }
    .test { margin: 20px 0; padding: 15px; background: #252526; border-left: 4px solid #007acc; }
    .pass { border-left-color: #4ec9b0; }
    .fail { border-left-color: #f48771; }
    .warning { border-left-color: #ce9178; }
    pre { background: #1e1e1e; padding: 10px; overflow-x: auto; font-size: 11px; }
    .label { color: #9cdcfe; font-weight: bold; }
    .error { color: #f48771; }
    .success { color: #4ec9b0; }
    table { border-collapse: collapse; width: 100%; margin: 10px 0; }
    th, td { border: 1px solid #3e3e42; padding: 8px; text-align: left; }
    th { background: #2d2d30; color: #9cdcfe; }
    .summary { font-size: 14px; padding: 20px; background: #252526; margin: 20px 0; }
  </style>

  <script src="../../src/core/lexicon.js"></script>
  <script>
    window.LEXICON_TAG_MAP = {
      "NN": ["NN"], "NNS": ["NNS"], "NNP": ["NNP"],
      "JJ": ["JJ"], "JJR": ["JJR"], "JJS": ["JJS"],
      "VB": ["VB"], "VBD": ["VBD"], "VBG": ["VBG"], "VBN": ["VBN"], "VBP": ["VBP"], "VBZ": ["VBZ"],
      "RB": ["RB"], "RBR": ["RBR"], "RBS": ["RBS"],
      "PRP": ["PRP"], "PRP$": ["PRP$"], "DT": ["DT"], "IN": ["IN"], "CC": ["CC"], "UH": ["UH"],
      "CD": ["CD"], "EX": ["EX"], "FW": ["FW"], "LS": ["LS"], "MD": ["MD"], "POS": ["POS"],
      "SYM": ["SYM"], "TO": ["TO"], "WDT": ["WDT"], "WP": ["WP"], "WP$": ["WP$"], "WRB": ["WRB"]
    };
  </script>
  <script src="../../src/core/POSTagger.js"></script>
  <script src="../../src/core/SemanticRoleExtractor.js"></script>
</head>
<body>
  <h1>IEE Test Corpus Validation - Week 1</h1>
  <p>Testing against official IEE test scenarios with full semantic parse validation...</p>

  <div id="results"></div>

  <script>
    const extractor = new SemanticRoleExtractor();

    // IEE Test Corpus - Week 1 (5 scenarios)
    const testCorpus = [
      {
        id: "healthcare-001",
        domain: "healthcare",
        title: "End of Life Decision",
        // Extract the key sentence to parse
        text: "The family must decide whether to continue treatment",
        expectedParse: {
          agent: { text: "family", entity: "family", posTag: "NN" },
          action: {
            verb: "decide",
            lemma: "decide",
            tense: "present",
            aspect: "simple",
            modality: "must",
            negation: false
          },
          patient: { text: "treatment", entity: "treatment" },
          semanticFrame: "Deciding",
          confidence: 0.85
        }
      },
      {
        id: "spiritual-001",
        domain: "spiritual",
        title: "Leaving Faith Community",
        text: "I am questioning core doctrines",
        expectedParse: {
          agent: { text: "I", entity: "self", posTag: "PRP" },
          action: {
            verb: "question",  // Note: "questioning" will lemmatize to "question"
            lemma: "question",
            tense: "present",
            aspect: "progressive",
            negation: false
          },
          patient: { text: "core_doctrines", entity: "core_doctrines" },  // Compound term
          semanticFrame: "Questioning",
          confidence: 0.82
        }
      },
      {
        id: "vocational-001",
        domain: "vocational",
        title: "Whistleblowing Decision",
        text: "I discovered that my company is falsifying safety reports",
        expectedParse: {
          agent: { text: "I", entity: "self", posTag: "PRP" },
          action: {
            verb: "discovered",
            lemma: "discover",
            tense: "past",
            aspect: "simple",
            negation: false
          },
          // Patient for "discovered" is more complex - we'll accept "company" as simplified
          semanticFrame: "Becoming_aware",
          confidence: 0.88
        }
      },
      {
        id: "interpersonal-001",
        domain: "interpersonal",
        title: "Friend's Infidelity",
        text: "My best friend is cheating on their spouse",
        expectedParse: {
          agent: { text: "best_friend", entity: "friend", posTag: "NN" },  // Compound term
          action: {
            verb: "cheat",  // "cheating" will lemmatize to "cheat"
            lemma: "cheat",
            tense: "present",
            aspect: "progressive",
            negation: false
          },
          patient: { text: "spouse", entity: "spouse" },
          semanticFrame: "Offenses",
          confidence: 0.80
        }
      },
      {
        id: "environmental-001",
        domain: "environmental",
        title: "Climate Action vs Economic Impact",
        text: "We must decide whether to allow an extension",
        expectedParse: {
          agent: { text: "We", entity: "community", posTag: "PRP" },
          action: {
            verb: "decide",
            lemma: "decide",
            tense: "present",
            aspect: "simple",
            modality: "must",
            negation: false
          },
          patient: { text: "extension", entity: "extension" },
          semanticFrame: "Deciding",
          confidence: 0.83
        }
      }
    ];

    let totalPass = 0;
    let totalFail = 0;
    let totalWarnings = 0;

    const aggregateScores = {
      agentMatch: 0,
      actionMatch: 0,
      patientMatch: 0,
      negationMatch: 0,
      frameMatch: 0,
      tenseMatch: 0,
      aspectMatch: 0
    };

    testCorpus.forEach(scenario => {
      const result = extractor.parseSemanticAction(scenario.text);
      const expected = scenario.expectedParse;

      // Detailed validation checks
      const checks = [];
      let errors = [];
      let warnings = [];

      // Agent validation
      if (result.agent && expected.agent) {
        const agentMatch = result.agent.text.toLowerCase() === expected.agent.text.toLowerCase();
        checks.push({ name: 'Agent text', pass: agentMatch,
                      expected: expected.agent.text, actual: result.agent?.text });
        if (agentMatch) aggregateScores.agentMatch++;
        else errors.push(`Agent mismatch: expected "${expected.agent.text}", got "${result.agent?.text}"`);

        const entityMatch = result.agent.entity === expected.agent.entity;
        checks.push({ name: 'Agent entity', pass: entityMatch,
                      expected: expected.agent.entity, actual: result.agent?.entity });
        if (!entityMatch) warnings.push(`Agent entity: expected "${expected.agent.entity}", got "${result.agent?.entity}"`);

        const posTagMatch = result.agent.posTag === expected.agent.posTag;
        checks.push({ name: 'Agent posTag', pass: posTagMatch,
                      expected: expected.agent.posTag, actual: result.agent?.posTag });
        if (!posTagMatch) warnings.push(`Agent POS tag: expected "${expected.agent.posTag}", got "${result.agent?.posTag}"`);
      } else {
        checks.push({ name: 'Agent present', pass: false });
        errors.push('Agent missing from parse');
      }

      // Action validation
      if (result.action && expected.action) {
        const lemmaMatch = result.action.lemma === expected.action.lemma;
        checks.push({ name: 'Action lemma', pass: lemmaMatch,
                      expected: expected.action.lemma, actual: result.action?.lemma });
        if (lemmaMatch) aggregateScores.actionMatch++;
        else errors.push(`Action lemma: expected "${expected.action.lemma}", got "${result.action?.lemma}"`);

        const tenseMatch = result.action.tense === expected.action.tense;
        checks.push({ name: 'Tense', pass: tenseMatch,
                      expected: expected.action.tense, actual: result.action?.tense });
        if (tenseMatch) aggregateScores.tenseMatch++;
        else warnings.push(`Tense: expected "${expected.action.tense}", got "${result.action?.tense}"`);

        const aspectMatch = result.action.aspect === expected.action.aspect;
        checks.push({ name: 'Aspect', pass: aspectMatch,
                      expected: expected.action.aspect, actual: result.action?.aspect });
        if (aspectMatch) aggregateScores.aspectMatch++;
        else warnings.push(`Aspect: expected "${expected.action.aspect}", got "${result.action?.aspect}"`);

        const negationMatch = result.action.negation === expected.action.negation;
        checks.push({ name: 'Negation', pass: negationMatch,
                      expected: expected.action.negation, actual: result.action?.negation });
        if (negationMatch) aggregateScores.negationMatch++;
        else errors.push(`CRITICAL: Negation: expected ${expected.action.negation}, got ${result.action?.negation}`);

        if (expected.action.modality) {
          const modalityMatch = result.action.modality === expected.action.modality;
          checks.push({ name: 'Modality', pass: modalityMatch,
                        expected: expected.action.modality, actual: result.action?.modality });
          if (!modalityMatch) warnings.push(`Modality: expected "${expected.action.modality}", got "${result.action?.modality}"`);
        }
      }

      // Patient validation (optional)
      if (expected.patient) {
        if (result.patient) {
          const patientMatch = result.patient.text === expected.patient.text;
          checks.push({ name: 'Patient text', pass: patientMatch,
                        expected: expected.patient.text, actual: result.patient?.text });
          if (patientMatch) aggregateScores.patientMatch++;
          else warnings.push(`Patient: expected "${expected.patient.text}", got "${result.patient?.text}"`);
        } else {
          checks.push({ name: 'Patient present', pass: false });
          warnings.push('Patient expected but not found');
        }
      }

      // Semantic frame validation
      const frameMatch = result.semanticFrame === expected.semanticFrame;
      checks.push({ name: 'Semantic frame', pass: frameMatch,
                    expected: expected.semanticFrame, actual: result.semanticFrame });
      if (frameMatch) aggregateScores.frameMatch++;
      else errors.push(`Frame: expected "${expected.semanticFrame}", got "${result.semanticFrame}"`);

      // Confidence validation
      const hasConfidence = typeof result.confidence === 'number' &&
                           result.confidence >= 0 && result.confidence <= 1;
      checks.push({ name: 'Confidence valid', pass: hasConfidence,
                    expected: '0-1', actual: result.confidence });

      // Overall pass/fail
      const passed = checks.filter(c => c.pass).length;
      const total = checks.length;
      const passRate = (passed / total * 100).toFixed(0);
      const testPass = errors.length === 0;

      if (testPass) totalPass++;
      else totalFail++;
      totalWarnings += warnings.length;

      // Generate HTML output
      const html = `
        <div class="test ${testPass ? 'pass' : 'fail'}">
          <h2>${testPass ? '‚úÖ' : '‚ùå'} ${scenario.id}: ${scenario.title} (${passRate}%)</h2>
          <p><span class="label">Domain:</span> ${scenario.domain}</p>
          <p><span class="label">Input:</span> "${scenario.text}"</p>

          <h3>Validation Results:</h3>
          <table>
            <tr><th>Check</th><th>Expected</th><th>Actual</th><th>Status</th></tr>
            ${checks.map(c => `
              <tr>
                <td>${c.name}</td>
                <td>${c.expected !== undefined ? c.expected : 'N/A'}</td>
                <td>${c.actual !== undefined ? c.actual : 'N/A'}</td>
                <td>${c.pass ? '<span class="success">‚úì</span>' : '<span class="error">‚úó</span>'}</td>
              </tr>
            `).join('')}
          </table>

          ${errors.length > 0 ? `
            <h3 class="error">Errors (${errors.length}):</h3>
            <ul>${errors.map(e => `<li class="error">${e}</li>`).join('')}</ul>
          ` : ''}

          ${warnings.length > 0 ? `
            <h3 style="color: #ce9178;">Warnings (${warnings.length}):</h3>
            <ul>${warnings.map(w => `<li style="color: #ce9178;">${w}</li>`).join('')}</ul>
          ` : ''}

          <h3>Full Parse Output:</h3>
          <pre>${JSON.stringify(result, null, 2)}</pre>
        </div>
      `;

      document.getElementById('results').innerHTML += html;
    });

    // Summary
    const overallPassRate = (totalPass / testCorpus.length * 100).toFixed(0);
    const agentAccuracy = (aggregateScores.agentMatch / testCorpus.length * 100).toFixed(0);
    const actionAccuracy = (aggregateScores.actionMatch / testCorpus.length * 100).toFixed(0);
    const patientAccuracy = (aggregateScores.patientMatch / testCorpus.length * 100).toFixed(0);
    const negationAccuracy = (aggregateScores.negationMatch / testCorpus.length * 100).toFixed(0);
    const frameAccuracy = (aggregateScores.frameMatch / testCorpus.length * 100).toFixed(0);
    const tenseAccuracy = (aggregateScores.tenseMatch / testCorpus.length * 100).toFixed(0);
    const aspectAccuracy = (aggregateScores.aspectMatch / testCorpus.length * 100).toFixed(0);

    const summaryHtml = `
      <div class="summary ${overallPassRate >= 75 ? 'pass' : 'fail'}">
        <h2>üìä Overall Results</h2>
        <p><span class="label">Total Scenarios:</span> ${testCorpus.length}</p>
        <p><span class="label">Passed:</span> <span class="success">${totalPass}</span></p>
        <p><span class="label">Failed:</span> <span class="error">${totalFail}</span></p>
        <p><span class="label">Warnings:</span> ${totalWarnings}</p>
        <p><span class="label">Pass Rate:</span> <strong>${overallPassRate}%</strong> ${overallPassRate >= 75 ? '‚úÖ MEETS WEEK 1 TARGET (‚â•75%)' : '‚ùå BELOW TARGET'}</p>

        <h3>Accuracy Breakdown:</h3>
        <table>
          <tr><th>Component</th><th>Accuracy</th><th>Status</th></tr>
          <tr><td>Agent Extraction</td><td>${agentAccuracy}%</td><td>${agentAccuracy >= 75 ? '‚úÖ' : '‚ö†Ô∏è'}</td></tr>
          <tr><td>Action Extraction</td><td>${actionAccuracy}%</td><td>${actionAccuracy >= 75 ? '‚úÖ' : '‚ö†Ô∏è'}</td></tr>
          <tr><td>Patient Extraction</td><td>${patientAccuracy}%</td><td>${patientAccuracy >= 50 ? '‚úÖ' : '‚ö†Ô∏è'}</td></tr>
          <tr><td>Negation Detection</td><td>${negationAccuracy}%</td><td>${negationAccuracy >= 95 ? '‚úÖ' : '‚ö†Ô∏è'}</td></tr>
          <tr><td>Frame Classification</td><td>${frameAccuracy}%</td><td>${frameAccuracy >= 75 ? '‚úÖ' : '‚ö†Ô∏è'}</td></tr>
          <tr><td>Tense Detection</td><td>${tenseAccuracy}%</td><td>${tenseAccuracy >= 70 ? '‚úÖ' : '‚ö†Ô∏è'}</td></tr>
          <tr><td>Aspect Detection</td><td>${aspectAccuracy}%</td><td>${aspectAccuracy >= 70 ? '‚úÖ' : '‚ö†Ô∏è'}</td></tr>
        </table>

        <p style="margin-top: 20px;">
          ${overallPassRate >= 75 ?
            '<span class="success">‚úÖ TagTeam Week 1 deliverable meets IEE integration requirements!</span>' :
            '<span class="error">‚ö†Ô∏è Additional work needed to meet 75% target.</span>'}
        </p>
      </div>
    `;

    document.getElementById('results').innerHTML = summaryHtml + document.getElementById('results').innerHTML;
  </script>
</body>
</html>
