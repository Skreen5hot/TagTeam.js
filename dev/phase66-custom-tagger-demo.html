<!DOCTYPE html>
<html lang="en">
<head><base href="/TagTeam.js/dev/"><style id="dev-theme">:root{--dev-bg:#111;--dev-fg:#e0e0e0;--dev-accent:#ff9800}body{background:var(--dev-bg)!important;color:var(--dev-fg)!important}.container,div[class]{background:var(--dev-bg)!important;color:var(--dev-fg)!important;border-color:#333!important}a{color:var(--dev-accent)!important}pre,code,textarea{background:#1a1a1a!important;color:#ccc!important;border-color:#333!important}h1,h2,h3{color:var(--dev-fg)!important}button{filter:brightness(0.85)}h1::after{content:" [DEV]";color:var(--dev-accent);font-size:0.6em}</style>
  <meta charset="UTF-8">
  <title>TagTeam.js - Phase 6.6: Custom Ontology Tagger</title>
  <style>
    * { box-sizing: border-box; }
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      margin: 0;
      padding: 0;
      background: linear-gradient(135deg, #0f2027 0%, #203a43 50%, #2c5364 100%);
      min-height: 100vh;
      color: #e8e8e8;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 40px 20px;
    }

    header {
      text-align: center;
      margin-bottom: 40px;
    }

    h1 {
      font-size: 2.5em;
      margin: 0;
      background: linear-gradient(90deg, #a855f7, #ec4899);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .subtitle {
      color: #888;
      font-size: 1.2em;
      margin-top: 10px;
    }

    .version-badge {
      display: inline-block;
      background: linear-gradient(90deg, #a855f7, #ec4899);
      color: #fff;
      padding: 5px 15px;
      border-radius: 20px;
      font-weight: bold;
      font-size: 0.9em;
      margin-top: 15px;
    }

    .format-badge {
      display: inline-block;
      background: rgba(168, 85, 247, 0.2);
      border: 1px solid rgba(168, 85, 247, 0.4);
      color: #c084fc;
      padding: 3px 10px;
      border-radius: 12px;
      font-size: 0.8em;
      margin-left: 8px;
    }

    .step-flow {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 10px;
      margin: 25px 0;
      flex-wrap: wrap;
    }

    .step-box {
      background: rgba(168, 85, 247, 0.15);
      border: 1px solid rgba(168, 85, 247, 0.3);
      padding: 10px 18px;
      border-radius: 10px;
      font-size: 0.95em;
      text-align: center;
    }

    .step-arrow {
      color: #a855f7;
      font-size: 1.3em;
    }

    .demo-section {
      background: rgba(255,255,255,0.05);
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 16px;
      padding: 30px;
      margin-bottom: 30px;
      backdrop-filter: blur(10px);
    }

    .demo-section h2 {
      color: #c084fc;
      margin-top: 0;
      font-size: 1.5em;
      border-bottom: 2px solid rgba(168, 85, 247, 0.3);
      padding-bottom: 10px;
    }

    .two-col {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
    }

    @media (max-width: 768px) {
      .two-col { grid-template-columns: 1fr; }
    }

    .col-label {
      font-size: 0.9em;
      color: #a78bfa;
      margin-bottom: 6px;
      font-weight: 600;
    }

    textarea {
      width: 100%;
      background: #0d1117;
      color: #c9d1d9;
      border: 1px solid rgba(255,255,255,0.15);
      border-radius: 8px;
      padding: 14px;
      font-family: 'Consolas', 'Monaco', monospace;
      font-size: 0.85em;
      line-height: 1.5;
      resize: vertical;
    }

    textarea:focus {
      outline: none;
      border-color: #a855f7;
      box-shadow: 0 0 0 2px rgba(168, 85, 247, 0.2);
    }

    .field-group {
      margin-bottom: 12px;
    }

    .field-group label {
      display: block;
      font-size: 0.85em;
      color: #a78bfa;
      margin-bottom: 4px;
    }

    .field-group input {
      width: 100%;
      background: #0d1117;
      color: #c9d1d9;
      border: 1px solid rgba(255,255,255,0.15);
      border-radius: 6px;
      padding: 8px 12px;
      font-family: 'Consolas', monospace;
      font-size: 0.85em;
    }

    .field-group input:focus {
      outline: none;
      border-color: #a855f7;
    }

    .field-group .hint {
      font-size: 0.75em;
      color: #666;
      margin-top: 2px;
    }

    .field-row {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
    }

    button {
      background: linear-gradient(90deg, #a855f7, #ec4899);
      color: #fff;
      border: none;
      padding: 12px 28px;
      border-radius: 8px;
      font-size: 1em;
      cursor: pointer;
      font-weight: 600;
      transition: opacity 0.2s;
      margin-top: 10px;
    }

    button:hover { opacity: 0.9; }

    button.secondary {
      background: rgba(255,255,255,0.1);
      border: 1px solid rgba(255,255,255,0.2);
      font-size: 0.85em;
      padding: 8px 16px;
    }

    .results-area {
      margin-top: 20px;
      display: none;
    }

    .results-area.show { display: block; }

    .result-card {
      background: rgba(255,255,255,0.03);
      border: 1px solid rgba(255,255,255,0.1);
      border-left: 4px solid #a855f7;
      border-radius: 10px;
      padding: 20px;
      margin-bottom: 15px;
    }

    .result-card h3 {
      margin-top: 0;
      color: #c084fc;
    }

    .tag-row {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 8px 0;
      border-bottom: 1px solid rgba(255,255,255,0.05);
      flex-wrap: wrap;
    }

    .tag {
      display: inline-block;
      padding: 4px 12px;
      border-radius: 16px;
      font-size: 0.85em;
      font-weight: 600;
    }

    .tag-class {
      background: rgba(168, 85, 247, 0.2);
      color: #c084fc;
      border: 1px solid rgba(168, 85, 247, 0.4);
    }

    .tag-category {
      background: rgba(59, 130, 246, 0.2);
      color: #93c5fd;
      border: 1px solid rgba(59, 130, 246, 0.4);
    }

    .tag-evidence {
      background: rgba(16, 185, 129, 0.2);
      color: #6ee7b7;
      border: 1px solid rgba(16, 185, 129, 0.4);
    }

    .tag-polarity-up {
      background: rgba(16, 185, 129, 0.2);
      color: #6ee7b7;
    }

    .tag-polarity-down {
      background: rgba(239, 68, 68, 0.2);
      color: #fca5a5;
    }

    .tag-polarity-neutral {
      background: rgba(156, 163, 175, 0.2);
      color: #9ca3af;
    }

    .tag-meta {
      background: rgba(245, 158, 11, 0.15);
      color: #fbbf24;
      font-size: 0.8em;
    }

    .confidence-bar {
      width: 60px;
      height: 8px;
      background: rgba(255,255,255,0.1);
      border-radius: 4px;
      overflow: hidden;
      display: inline-block;
      vertical-align: middle;
      margin-left: 8px;
    }

    .confidence-fill {
      height: 100%;
      border-radius: 4px;
      background: linear-gradient(90deg, #a855f7, #ec4899);
    }

    .stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 12px;
      margin-bottom: 15px;
    }

    .stat-box {
      text-align: center;
      padding: 12px;
      background: rgba(255,255,255,0.05);
      border-radius: 8px;
    }

    .stat-number {
      font-size: 1.8em;
      font-weight: bold;
      color: #c084fc;
    }

    .stat-label {
      font-size: 0.8em;
      color: #888;
    }

    .example-btn {
      display: inline-block;
      background: rgba(168, 85, 247, 0.15);
      border: 1px solid rgba(168, 85, 247, 0.3);
      color: #c084fc;
      padding: 6px 14px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.85em;
      margin: 4px;
      transition: background 0.2s;
    }

    .example-btn:hover {
      background: rgba(168, 85, 247, 0.3);
    }

    .highlight {
      background: rgba(168, 85, 247, 0.3);
      border-radius: 3px;
      padding: 1px 3px;
    }

    .highlighted-text {
      background: #0d1117;
      padding: 15px;
      border-radius: 8px;
      line-height: 1.8;
      font-size: 1em;
      border: 1px solid rgba(255,255,255,0.1);
    }

    .back-link {
      display: inline-block;
      color: #888;
      text-decoration: none;
      margin-bottom: 20px;
      font-size: 0.9em;
    }

    .back-link:hover { color: #c084fc; }

    .validation-msg {
      padding: 10px 15px;
      border-radius: 8px;
      margin-top: 10px;
      font-size: 0.85em;
    }

    .validation-ok {
      background: rgba(16, 185, 129, 0.15);
      border: 1px solid rgba(16, 185, 129, 0.3);
      color: #6ee7b7;
    }

    .validation-warn {
      background: rgba(245, 158, 11, 0.15);
      border: 1px solid rgba(245, 158, 11, 0.3);
      color: #fbbf24;
    }

    .validation-err {
      background: rgba(239, 68, 68, 0.15);
      border: 1px solid rgba(239, 68, 68, 0.3);
      color: #fca5a5;
    }

    /* Match Evidence Audit */
    .evidence-table {
      width: 100%;
      border-collapse: collapse;
      margin: 10px 0;
      font-size: 0.85em;
    }

    .evidence-table th {
      text-align: left;
      padding: 8px 10px;
      background: rgba(255,255,255,0.05);
      color: #a78bfa;
      font-weight: 600;
      border-bottom: 1px solid rgba(255,255,255,0.1);
    }

    .evidence-table td {
      padding: 6px 10px;
      border-bottom: 1px solid rgba(255,255,255,0.05);
      color: #c9d1d9;
      vertical-align: top;
    }

    .evidence-table code {
      background: rgba(168, 85, 247, 0.15);
      padding: 2px 6px;
      border-radius: 4px;
      font-size: 0.9em;
      color: #c084fc;
    }

    .tag-exact {
      background: rgba(16, 185, 129, 0.25);
      color: #6ee7b7;
      border: 1px solid rgba(16, 185, 129, 0.4);
    }

    .tag-partial {
      background: rgba(245, 158, 11, 0.2);
      color: #fbbf24;
      border: 1px solid rgba(245, 158, 11, 0.4);
    }

    .tag-keyword {
      background: rgba(59, 130, 246, 0.2);
      color: #93c5fd;
      border: 1px solid rgba(59, 130, 246, 0.4);
    }

    .evidence-class-header {
      color: #c084fc;
      font-size: 1.05em;
      margin: 18px 0 6px 0;
      padding-bottom: 4px;
      border-bottom: 1px solid rgba(168, 85, 247, 0.2);
    }

    .evidence-class-header:first-child {
      margin-top: 0;
    }

    .evidence-iri {
      font-size: 0.75em;
      color: #666;
      font-weight: normal;
      margin-left: 8px;
    }
  </style>
</head>
<body>
  <div class="container">
    <a href="index.html" class="back-link">&#x2190; Back to TagTeam.js</a>

    <header>
      <h1>Custom Ontology Tagger</h1>
      <p class="subtitle">Load any TTL ontology. Tag any text. No code required.</p>
      <span class="version-badge">Phase 6.6</span>
      <span class="format-badge">TTL / Turtle</span>
    </header>

    <div class="step-flow">
      <div class="step-box">1. Paste TTL Ontology</div>
      <span class="step-arrow">&#x2192;</span>
      <div class="step-box">2. Map Properties</div>
      <span class="step-arrow">&#x2192;</span>
      <div class="step-box">3. Enter Text</div>
      <span class="step-arrow">&#x2192;</span>
      <div class="step-box">4. See Tags</div>
    </div>

    <!-- STEP 1: Ontology Input -->
    <div class="demo-section">
      <h2>Step 1: Your Ontology</h2>
      <p style="color:#aaa; margin-bottom:15px;">
        Paste your ontology in <strong>Turtle/TTL</strong> format below, or load an example.
        Each class needs an <code>rdf:type</code> declaration (<code>a SomeType</code>) and
        at least one property with comma-separated keywords.
      </p>

      <div style="margin-bottom:15px;">
        <span style="color:#888; font-size:0.85em;">Load example:</span>
        <span class="example-btn" onclick="loadExample('medical')">Medical</span>
        <span class="example-btn" onclick="loadExample('legal')">Legal</span>
        <span class="example-btn" onclick="loadExample('environmental')">Environmental</span>
      </div>

      <textarea id="ttl-input" rows="16" spellcheck="false" placeholder="@prefix myns: <https://example.org/myontology#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .

myns:MyClass a myns:MyType ;
    rdfs:label &quot;My Class&quot; ;
    myns:keywords &quot;term1, term2, term3&quot; ;
    myns:category myns:SomeCategory ."></textarea>
    </div>

    <!-- STEP 2: Property Mapping -->
    <div class="demo-section">
      <h2>Step 2: Property Mapping</h2>
      <p style="color:#aaa; margin-bottom:15px;">
        Tell us which predicates in your ontology serve which role.
        Only <strong>Keywords</strong> is required &mdash; the rest are optional.
      </p>

      <div class="field-row">
        <div class="field-group">
          <label>Keywords predicate *</label>
          <input type="text" id="map-keywords" value="med:indicators" placeholder="myns:keywords" />
          <div class="hint">Which property holds the search/matching terms</div>
        </div>
        <div class="field-group">
          <label>Type filter</label>
          <input type="text" id="map-typeFilter" value="" placeholder="myns:MyType (blank = all types)" />
          <div class="hint">Only tag classes of this rdf:type (leave blank for all)</div>
        </div>
      </div>

      <div class="field-row">
        <div class="field-group">
          <label>Category predicate</label>
          <input type="text" id="map-category" value="med:category" placeholder="myns:category" />
          <div class="hint">Groups results by this property</div>
        </div>
        <div class="field-group">
          <label>Domain label</label>
          <input type="text" id="map-domain" value="medical" placeholder="my-domain" />
          <div class="hint">Label attached to output results</div>
        </div>
      </div>

      <div class="field-row">
        <div class="field-group">
          <label>Upholding predicate</label>
          <input type="text" id="map-upholding" value="" placeholder="myns:positiveTerms" />
          <div class="hint">Positive/upholding polarity indicators</div>
        </div>
        <div class="field-group">
          <label>Violating predicate</label>
          <input type="text" id="map-violating" value="" placeholder="myns:negativeTerms" />
          <div class="hint">Negative/violating polarity indicators</div>
        </div>
      </div>

      <div class="field-group">
        <label>Extra properties (comma-separated)</label>
        <input type="text" id="map-extra" value="med:icdCode, med:riskFactors" placeholder="myns:code, myns:source" />
        <div class="hint">Additional properties to include as metadata on each result</div>
      </div>
    </div>

    <!-- STEP 3: Text Input -->
    <div class="demo-section">
      <h2>Step 3: Text to Analyze</h2>
      <p style="color:#aaa; margin-bottom:15px;">
        Enter or paste text. The tagger will find instances of your ontology classes.
      </p>

      <textarea id="text-input" rows="5" placeholder="Enter text to analyze...">Patient presents with chest pain and shortness of breath. Blood sugar levels are elevated, suggesting possible diabetes. Also reports persistent cough and fever for three days.</textarea>

      <div style="margin-top:15px;">
        <button onclick="runTagger()">Tag Text</button>
        <button class="secondary" onclick="validateMap()" style="margin-left:10px;">Validate Mapping</button>
        <label style="display:inline-flex;align-items:center;gap:6px;margin-left:15px;font-size:0.9em;color:#888;cursor:pointer;">
          <input type="checkbox" id="verbose-toggle"> Show POS Tags
        </label>
      </div>

      <div id="validation-output"></div>
    </div>

    <!-- STEP 4: Results -->
    <div id="results-area" class="results-area">
      <div class="demo-section">
        <h2>Results</h2>
        <div id="results-content"></div>
      </div>
    </div>

    <!-- How It Works -->
    <div class="demo-section">
      <h2>How It Works</h2>
      <p style="color:#aaa; line-height:1.7;">
        The <strong>OntologyTextTagger</strong> reads your TTL ontology using TagTeam's built-in
        <code>TurtleParser</code>, then applies your <strong>property mapping</strong> to extract
        tag definitions. Each class becomes a taggable concept with keywords drawn from whatever
        predicate you specify. When you enter text, the tagger scans for keyword matches using
        word-boundary regex and reports which ontology classes were detected, with evidence,
        confidence scores, categories, and any extra metadata.
      </p>

      <div style="margin-top:20px;">
        <h3 style="color:#a78bfa;">Accepted Format: Turtle / TTL</h3>
        <p style="color:#aaa;">Your ontology must be in <strong>Turtle</strong> (Terse RDF Triple Language) format. Key requirements:</p>
        <ul style="color:#aaa; line-height:1.8; margin-left:20px;">
          <li>Each class needs an <code>rdf:type</code> declaration (use <code>a</code> shorthand)</li>
          <li>At least one property with <strong>comma-separated keywords</strong> for matching</li>
          <li>Use <code>@prefix</code> declarations for namespaces</li>
          <li><code>rdfs:label</code> provides the display name (falls back to local name if missing)</li>
          <li>Properties for category, polarity, and metadata are all optional</li>
        </ul>
      </div>

      <div style="margin-top:20px;">
        <h3 style="color:#a78bfa;">Minimal Example</h3>
        <pre style="background:#0d1117; padding:15px; border-radius:8px; overflow-x:auto; font-size:0.85em; color:#c9d1d9;">@prefix ex: &lt;https://example.org/#&gt; .
@prefix rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt; .

ex:Concept a ex:MyType ;
    rdfs:label "My Concept" ;
    ex:terms "keyword1, keyword2, keyword3" .

<span style="color:#6a9955;">## Property map: { keywords: 'ex:terms' }</span></pre>
      </div>
    </div>
  </div>

  <!-- Load TagTeam bundle -->
  <script>
    var scriptPath = (window.location.hostname === 'localhost' || window.location.protocol === 'file:')
      ? '../dist/tagteam.js'
      : 'tagteam.js';
  </script>
  <script>
    // Load tagteam.js: use local dist for dev, same-directory for GitHub Pages
    (function() {
      var isGitHubPages = window.location.hostname === 'github.io' || window.location.hostname.endsWith('.github.io');
      var s = document.createElement('script');
      s.src = isGitHubPages ? 'tagteam.js' : '../dist/tagteam.js';
      if (!isGitHubPages) {
        s.onerror = function() {
          var s2 = document.createElement('script');
          s2.src = 'tagteam.js';
          document.head.appendChild(s2);
        };
      }
      document.head.appendChild(s);
    })();
  </script>

  <script>
    function escapeHtml(str) {
      var div = document.createElement('div');
      div.textContent = str;
      return div.innerHTML;
    }

    // =========================================================================
    // Example Ontologies
    // =========================================================================

    var EXAMPLES = {
      medical: {
        ttl: [
          '@prefix med: <https://example.org/medical#> .',
          '@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .',
          '@prefix bfo: <http://purl.obolibrary.org/obo/BFO_> .',
          '',
          'med:CardiovascularDisease a bfo:0000016 ;',
          '    rdfs:label "Cardiovascular Disease" ;',
          '    med:indicators "chest pain, shortness of breath, heart attack, stroke, hypertension" ;',
          '    med:icdCode "I00-I99" ;',
          '    med:riskFactors "smoking, obesity, diabetes" ;',
          '    med:category med:ChronicDisease .',
          '',
          'med:RespiratoryInfection a bfo:0000016 ;',
          '    rdfs:label "Respiratory Infection" ;',
          '    med:indicators "cough, fever, congestion, pneumonia, bronchitis" ;',
          '    med:icdCode "J00-J99" ;',
          '    med:riskFactors "weak immune system, smoking" ;',
          '    med:category med:AcuteDisease .',
          '',
          'med:Diabetes a bfo:0000016 ;',
          '    rdfs:label "Diabetes" ;',
          '    med:indicators "blood sugar, insulin, glucose, thirst, fatigue" ;',
          '    med:icdCode "E08-E13" ;',
          '    med:riskFactors "obesity, sedentary, genetics" ;',
          '    med:category med:ChronicDisease .',
          '',
          'med:MentalHealth a bfo:0000016 ;',
          '    rdfs:label "Mental Health Disorder" ;',
          '    med:indicators "anxiety, depression, insomnia, mood changes, panic" ;',
          '    med:icdCode "F00-F99" ;',
          '    med:category med:ChronicDisease .'
        ].join('\n'),
        mapping: {
          keywords: 'med:indicators',
          typeFilter: '',
          category: 'med:category',
          domain: 'medical',
          upholding: '',
          violating: '',
          extra: 'med:icdCode, med:riskFactors'
        },
        text: 'Patient presents with chest pain and shortness of breath. Blood sugar levels are elevated, suggesting possible diabetes. Also reports persistent cough and fever for three days.'
      },

      legal: {
        ttl: [
          '@prefix legal: <https://example.org/legal#> .',
          '@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .',
          '',
          'legal:ContractBreach a legal:LegalConcept ;',
          '    rdfs:label "Breach of Contract" ;',
          '    legal:searchTerms "breach, violated agreement, failed to perform, non-performance" ;',
          '    legal:positiveResolution "cure, remedy, settlement, mediation" ;',
          '    legal:negativeOutcome "damages, penalty, termination, liability" ;',
          '    legal:jurisdiction "common-law" ;',
          '    legal:category legal:ContractLaw .',
          '',
          'legal:Negligence a legal:LegalConcept ;',
          '    rdfs:label "Negligence" ;',
          '    legal:searchTerms "negligence, duty of care, reasonable person, careless" ;',
          '    legal:positiveResolution "settlement, compensation" ;',
          '    legal:negativeOutcome "damages, injury, harm" ;',
          '    legal:jurisdiction "common-law" ;',
          '    legal:category legal:TortLaw .',
          '',
          'legal:IPInfringement a legal:LegalConcept ;',
          '    rdfs:label "IP Infringement" ;',
          '    legal:searchTerms "infringement, copyright, trademark, patent violation" ;',
          '    legal:positiveResolution "licensing, consent agreement" ;',
          '    legal:negativeOutcome "injunction, statutory damages" ;',
          '    legal:jurisdiction "federal" ;',
          '    legal:category legal:IPLaw .'
        ].join('\n'),
        mapping: {
          keywords: 'legal:searchTerms',
          typeFilter: 'legal:LegalConcept',
          category: 'legal:category',
          domain: 'legal',
          upholding: 'legal:positiveResolution',
          violating: 'legal:negativeOutcome',
          extra: 'legal:jurisdiction'
        },
        text: 'The defendant was found negligent in their duty of care, resulting in significant damages. The plaintiff also alleges breach of contract and seeks remedy through settlement. A separate copyright infringement claim was dismissed.'
      },

      environmental: {
        ttl: [
          '@prefix env: <https://example.org/environmental#> .',
          '@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .',
          '',
          'env:WaterPollution a env:EnvironmentalHazard ;',
          '    rdfs:label "Water Pollution" ;',
          '    env:keywords "discharge, effluent, contamination, river, groundwater, runoff" ;',
          '    env:severity "high" ;',
          '    env:category env:PollutionType .',
          '',
          'env:AirPollution a env:EnvironmentalHazard ;',
          '    rdfs:label "Air Pollution" ;',
          '    env:keywords "emissions, smog, particulate, ozone, exhaust, carbon" ;',
          '    env:severity "high" ;',
          '    env:category env:PollutionType .',
          '',
          'env:Deforestation a env:EnvironmentalHazard ;',
          '    rdfs:label "Deforestation" ;',
          '    env:keywords "logging, clear-cut, forest loss, habitat destruction, timber" ;',
          '    env:severity "medium" ;',
          '    env:category env:LandUse .',
          '',
          'env:SoilErosion a env:EnvironmentalHazard ;',
          '    rdfs:label "Soil Erosion" ;',
          '    env:keywords "erosion, topsoil loss, sedimentation, degradation" ;',
          '    env:severity "medium" ;',
          '    env:category env:LandUse .'
        ].join('\n'),
        mapping: {
          keywords: 'env:keywords',
          typeFilter: 'env:EnvironmentalHazard',
          category: 'env:category',
          domain: 'environmental',
          upholding: '',
          violating: '',
          extra: 'env:severity'
        },
        text: 'The factory has been discharging effluent into the river for months, causing severe contamination of groundwater. Nearby logging operations have led to significant forest loss and soil erosion. Air quality monitoring shows elevated particulate and smog levels from industrial exhaust emissions.'
      }
    };

    // =========================================================================
    // UI Functions
    // =========================================================================

    function loadExample(name) {
      var ex = EXAMPLES[name];
      if (!ex) return;

      document.getElementById('ttl-input').value = ex.ttl;
      document.getElementById('map-keywords').value = ex.mapping.keywords;
      document.getElementById('map-typeFilter').value = ex.mapping.typeFilter;
      document.getElementById('map-category').value = ex.mapping.category;
      document.getElementById('map-domain').value = ex.mapping.domain;
      document.getElementById('map-upholding').value = ex.mapping.upholding;
      document.getElementById('map-violating').value = ex.mapping.violating;
      document.getElementById('map-extra').value = ex.mapping.extra;
      document.getElementById('text-input').value = ex.text;

      // Clear previous results
      document.getElementById('results-area').classList.remove('show');
      document.getElementById('validation-output').innerHTML = '';
    }

    function getPropertyMap() {
      var map = {
        keywords: document.getElementById('map-keywords').value.trim()
      };

      var typeFilter = document.getElementById('map-typeFilter').value.trim();
      if (typeFilter) map.typeFilter = typeFilter;

      var category = document.getElementById('map-category').value.trim();
      if (category) map.category = category;

      var upholding = document.getElementById('map-upholding').value.trim();
      if (upholding) map.upholding = upholding;

      var violating = document.getElementById('map-violating').value.trim();
      if (violating) map.violating = violating;

      var extra = document.getElementById('map-extra').value.trim();
      if (extra) {
        map.extraProperties = extra.split(',').map(function(s) { return s.trim(); }).filter(function(s) { return s; });
      }

      return map;
    }

    function validateMap() {
      var output = document.getElementById('validation-output');

      try {
        var ttl = document.getElementById('ttl-input').value.trim();
        if (!ttl) {
          output.innerHTML = '<div class="validation-msg validation-err">Please paste your TTL ontology first.</div>';
          return;
        }

        var propertyMap = getPropertyMap();
        if (!propertyMap.keywords) {
          output.innerHTML = '<div class="validation-msg validation-err">Keywords predicate is required.</div>';
          return;
        }

        var tagger = TagTeam.OntologyTextTagger.fromTTL(ttl, {
          propertyMap: propertyMap,
          domain: document.getElementById('map-domain').value.trim() || 'custom'
        });

        var validation = tagger.validatePropertyMap();
        var html = '';

        if (validation.valid) {
          html += '<div class="validation-msg validation-ok">';
          html += '<strong>&#x2705; Valid!</strong> Found ' + tagger.tagDefinitions.length + ' taggable classes.';
          if (validation.warnings.length > 0) {
            html += '<br><br><strong>Warnings:</strong><ul style="margin:5px 0 0 20px;">';
            for (var i = 0; i < validation.warnings.length; i++) {
              html += '<li>' + validation.warnings[i] + '</li>';
            }
            html += '</ul>';
          }
          html += '</div>';
        } else {
          html += '<div class="validation-msg validation-err">';
          html += '<strong>&#x274c; Errors found:</strong><ul style="margin:5px 0 0 20px;">';
          for (var j = 0; j < validation.errors.length; j++) {
            html += '<li>' + validation.errors[j] + '</li>';
          }
          html += '</ul></div>';
        }

        output.innerHTML = html;
      } catch (e) {
        output.innerHTML = '<div class="validation-msg validation-err"><strong>Error:</strong> ' + escapeHtml(e.message) + '</div>';
      }
    }

    function renderPosTokens(debug) {
      if (!debug || !debug.tokens || !debug.tokens.length) return '';
      var html = '<div class="result-card"><h3 style="color:#0ea5e9;">POS Tags (Verbose Mode)</h3>';
      html += '<div style="display:flex;flex-wrap:wrap;gap:8px;margin:10px 0;">';
      for (var i = 0; i < debug.tokens.length; i++) {
        var t = debug.tokens[i];
        var tagLabel = t.tags.join(', ');
        html += '<div style="background:#1e1e2e;border:1px solid #333;border-radius:6px;padding:6px 10px;text-align:center;">';
        html += '<div style="font-weight:bold;color:#cdd6f4;">' + t.text + '</div>';
        html += '<div style="font-size:0.75em;color:#89b4fa;">' + tagLabel + '</div>';
        html += '</div>';
      }
      html += '</div></div>';
      return html;
    }

    function runTagger() {
      var resultsArea = document.getElementById('results-area');
      var resultsContent = document.getElementById('results-content');

      try {
        var ttl = document.getElementById('ttl-input').value.trim();
        var text = document.getElementById('text-input').value.trim();

        if (!ttl) { alert('Please paste your TTL ontology.'); return; }
        if (!text) { alert('Please enter text to analyze.'); return; }

        var propertyMap = getPropertyMap();
        if (!propertyMap.keywords) { alert('Keywords predicate is required.'); return; }

        var domain = document.getElementById('map-domain').value.trim() || 'custom';

        // Create tagger
        var tagger = TagTeam.OntologyTextTagger.fromTTL(ttl, {
          propertyMap: propertyMap,
          domain: domain
        });

        // Get stats
        var stats = tagger.getStats();

        // Tag text
        var tags = tagger.tagText(text);
        var grouped = tagger.tagTextGrouped(text);

        var html = '';

        // Stats summary
        html += '<div class="stats-grid">';
        html += '<div class="stat-box"><div class="stat-number">' + stats.classCount + '</div><div class="stat-label">Classes Loaded</div></div>';
        html += '<div class="stat-box"><div class="stat-number">' + stats.totalKeywords + '</div><div class="stat-label">Total Keywords</div></div>';
        html += '<div class="stat-box"><div class="stat-number">' + tags.length + '</div><div class="stat-label">Tags Found</div></div>';
        html += '<div class="stat-box"><div class="stat-number">' + Object.keys(grouped).length + '</div><div class="stat-label">Categories</div></div>';
        html += '</div>';

        if (tags.length === 0) {
          html += '<div class="result-card"><h3>No Matches Found</h3>';
          html += '<p style="color:#aaa;">No ontology classes were detected in the text. Try adding more keywords to your ontology or using different text.</p>';
          html += '</div>';
        } else {
          // Highlighted text
          html += '<div class="result-card"><h3>&#x1f4dd; Highlighted Text</h3>';
          html += '<div class="highlighted-text">' + highlightText(text, tags) + '</div>';
          html += '</div>';

          // Tags by category
          var categories = Object.keys(grouped);
          for (var ci = 0; ci < categories.length; ci++) {
            var catName = categories[ci];
            var catTags = grouped[catName];
            var displayCat = catName === '_uncategorized' ? 'Uncategorized' : catName.split(':').pop();

            html += '<div class="result-card">';
            html += '<h3><span class="tag tag-category">' + displayCat + '</span> (' + catTags.length + ' match' + (catTags.length !== 1 ? 'es' : '') + ')</h3>';

            for (var ti = 0; ti < catTags.length; ti++) {
              var tag = catTags[ti];
              html += '<div class="tag-row">';

              // Class name
              html += '<span class="tag tag-class">' + tag.label + '</span>';

              // Confidence
              html += '<span style="color:#888; font-size:0.85em;">' + Math.round(tag.confidence * 100) + '%</span>';
              html += '<span class="confidence-bar"><span class="confidence-fill" style="width:' + (tag.confidence * 100) + '%;"></span></span>';

              // Polarity
              if (tag.polarity === 1) {
                html += '<span class="tag tag-polarity-up">&#x2191; upholding</span>';
              } else if (tag.polarity === -1) {
                html += '<span class="tag tag-polarity-down">&#x2193; violating</span>';
              }

              html += '</div>';

              // Evidence
              html += '<div style="padding:4px 0 8px 0;">';
              html += '<span style="color:#666; font-size:0.8em;">Evidence: </span>';
              for (var ei = 0; ei < tag.evidence.length; ei++) {
                html += '<span class="tag tag-evidence" style="margin:2px;">' + tag.evidence[ei] + '</span>';
              }
              html += '</div>';

              // Metadata
              if (tag.metadata) {
                html += '<div style="padding:0 0 8px 0;">';
                var metaKeys = Object.keys(tag.metadata);
                for (var mi = 0; mi < metaKeys.length; mi++) {
                  html += '<span class="tag tag-meta" style="margin:2px;">' + metaKeys[mi] + ': ' + tag.metadata[metaKeys[mi]] + '</span>';
                }
                html += '</div>';
              }
            }
            html += '</div>';
          }
        }

        // Build the real Two-Tier JSON-LD graph via TagTeam.buildGraph
        var verbose = document.getElementById('verbose-toggle').checked;
        var graphResult = TagTeam.buildGraph(text, { detectAmbiguity: true, verbose: verbose });
        var jsonld = graphResult['@graph'] ? graphResult : { '@graph': graphResult };

        // Enrich Tier 2 nodes with ontology class types from tags
        enrichGraphWithOntologyTypes(jsonld, tags);

        // Verbose mode: show POS tokens
        if (graphResult._debug) {
          html += renderPosTokens(graphResult._debug);
        }

        html += '<div class="result-card">';
        html += '<h3>Two-Tier JSON-LD Graph (Ontology-Enriched)</h3>';
        html += '<p style="color:#aaa;font-size:0.85em;margin-bottom:12px;">Tier 2 entity nodes are typed with matched ontology classes from your TTL.</p>';
        html += '<pre style="background:#1e1e2e;color:#cdd6f4;padding:16px;border-radius:8px;overflow-x:auto;font-size:0.85em;max-height:600px;border-left:4px solid #a855f7;">';
        html += syntaxHighlightJsonLd(jsonld);
        html += '</pre>';
        html += '<button onclick="copyJsonLd()" style="margin-top:8px;background:#a855f7;color:white;border:none;padding:8px 16px;border-radius:6px;cursor:pointer;font-size:0.85em;">Copy JSON-LD</button>';
        html += '</div>';

        // Store for copy button
        window._lastJsonLd = JSON.stringify(jsonld, null, 2);

        // Match Evidence Audit — independently parse TTL and check each property
        try {
          var auditResults = auditClassMatches(ttl, text, propertyMap.keywords);
          html += renderMatchEvidence(auditResults);
        } catch (auditErr) {
          console.warn('Match evidence audit error:', auditErr);
        }

        resultsContent.innerHTML = html;
        resultsArea.classList.add('show');
        resultsArea.scrollIntoView({ behavior: 'smooth' });

      } catch (e) {
        resultsContent.innerHTML = '<div class="result-card" style="border-left-color:#ef4444;"><h3 style="color:#fca5a5;">Error</h3><p>' + escapeHtml(e.message) + '</p></div>';
        resultsArea.classList.add('show');
        console.error(e);
      }
    }

    function enrichGraphWithOntologyTypes(jsonld, tags) {
      // Build a map of evidence terms → ontology class IRIs
      // For each tag, its evidence words are the link to Tier 2 entity nodes
      var graphNodes = jsonld['@graph'] || [];

      for (var ni = 0; ni < graphNodes.length; ni++) {
        var node = graphNodes[ni];
        var nodeTypes = node['@type'];
        if (!nodeTypes || !Array.isArray(nodeTypes)) continue;

        // Enrich Tier 2 entity nodes using blacklist approach:
        // Any node with owl:NamedIndividual that is NOT an infrastructure type
        var isTier2Entity = nodeTypes.indexOf('owl:NamedIndividual') >= 0;
        if (isTier2Entity) {
          for (var ti = 0; ti < nodeTypes.length; ti++) {
            var t = nodeTypes[ti];
            // Blacklist: infrastructure/non-entity types
            if (t === 'tagteam:DiscourseReferent' ||
                t === 'cco:AgentRole' || t === 'cco:PatientRole' ||
                t === 'cco:InstrumentRole' || t === 'cco:BeneficiaryRole' ||
                t === 'bfo:BFO_0000023' ||
                t === 'cco:IntentionalAct' ||
                t === 'cco:InformationBearingEntity' ||
                t === 'cco:ArtificialAgent' ||
                t === 'cco:InformationContentEntity' ||
                t === 'cco:ActOfArtificialProcessing' ||
                t === 'tagteam:DirectiveContent' ||
                t === 'tagteam:Inference' || t === 'tagteam:ClinicalFinding' ||
                t === 'tagteam:ScarcityAssertion' ||
                t === 'tagteam:InterpretationContext' ||
                t === 'tagteam:ValueAssertionEvent' ||
                t === 'tagteam:ContextAssessmentEvent' ||
                t === 'tagteam:AlternativeNode' ||
                t.indexOf('cco:ActOf') === 0) {  // catch all ActOf* subtypes
              isTier2Entity = false;
              break;
            }
          }
        }

        if (!isTier2Entity) continue;

        // Get the node's label to match against tag evidence
        var nodeLabel = (node['rdfs:label'] || '').toLowerCase();
        if (!nodeLabel) continue;

        // Check each tag's evidence for overlap with this entity's label
        for (var tgi = 0; tgi < tags.length; tgi++) {
          var tag = tags[tgi];
          var evidenceList = tag.evidence || [];
          for (var ei = 0; ei < evidenceList.length; ei++) {
            var ev = evidenceList[ei].toLowerCase();
            if (nodeLabel.indexOf(ev) >= 0) {
              // Match found — add the ontology class IRI to this node's @type
              var classIri = tag.iri || tag.class;
              if (classIri && nodeTypes.indexOf(classIri) === -1) {
                nodeTypes.push(classIri);
              }
              // Also annotate with confidence and evidence
              if (!node['tagteam:ontologyMatch']) {
                node['tagteam:ontologyMatch'] = [];
              }
              node['tagteam:ontologyMatch'].push({
                '@type': classIri,
                'tagteam:confidence': tag.confidence,
                'tagteam:evidence': ev
              });
              break; // One evidence match is enough for this tag
            }
          }
        }
      }
    }

    function syntaxHighlightJsonLd(obj) {
      var json = JSON.stringify(obj, null, 2);
      // Escape HTML first
      json = json.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
      // Highlight keys
      json = json.replace(/"(@?\w[^"]*)":/g, '<span style="color:#89b4fa;">"$1"</span>:');
      // Highlight string values (but not keys)
      json = json.replace(/: "((?:[^"\\]|\\.)*)"/g, ': <span style="color:#a6e3a1;">"$1"</span>');
      // Highlight numbers
      json = json.replace(/: (\d+\.?\d*)/g, ': <span style="color:#fab387;">$1</span>');
      // Highlight booleans
      json = json.replace(/: (true|false)/g, ': <span style="color:#f9e2af;">$1</span>');
      return json;
    }

    function copyJsonLd() {
      if (window._lastJsonLd) {
        navigator.clipboard.writeText(window._lastJsonLd).then(function() {
          alert('JSON-LD copied to clipboard!');
        });
      }
    }

    function highlightText(text, tags) {
      // Collect all evidence terms and build a replacement map
      var allEvidence = [];
      var evidenceToClass = {};

      for (var i = 0; i < tags.length; i++) {
        for (var j = 0; j < tags[i].evidence.length; j++) {
          var ev = tags[i].evidence[j];
          if (allEvidence.indexOf(ev) === -1) {
            allEvidence.push(ev);
          }
          evidenceToClass[ev.toLowerCase()] = tags[i].label;
        }
      }

      // Sort by length descending to match longer phrases first
      allEvidence.sort(function(a, b) { return b.length - a.length; });

      // Replace each evidence term with highlighted version
      var result = text;
      for (var k = 0; k < allEvidence.length; k++) {
        var term = allEvidence[k];
        var escaped = term.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        var regex = new RegExp('\\b(' + escaped + ')\\b', 'gi');
        var cls = evidenceToClass[term.toLowerCase()] || '';
        result = result.replace(regex, '<span class="highlight" title="' + cls + '">$1</span>');
      }

      return result;
    }

    // ---- Match Evidence Audit ----

    function auditClassMatches(ttlContent, text, keywordsPredicate) {
      var parser = new TagTeam.TurtleParser();
      var parsed = parser.parse(ttlContent);
      var lowerText = text.toLowerCase();

      // Standard properties to check + user-configured keywords property
      var AUDIT_PROPERTIES = [
        'rdfs:label', 'skos:prefLabel', 'skos:altLabel', 'rdfs:comment'
      ];
      if (keywordsPredicate && AUDIT_PROPERTIES.indexOf(keywordsPredicate) === -1) {
        AUDIT_PROPERTIES.push(keywordsPredicate);
      }

      var results = [];
      var subjects = parsed.getSubjects();

      for (var si = 0; si < subjects.length; si++) {
        var subj = subjects[si];
        var matches = [];

        for (var pi = 0; pi < AUDIT_PROPERTIES.length; pi++) {
          var prop = AUDIT_PROPERTIES[pi];
          var value = parsed.getProperty(subj, prop);
          if (!value) continue;

          var lowerValue = value.toLowerCase().trim();

          // 1) Exact match: full property value found in text
          if (lowerText.indexOf(lowerValue) !== -1) {
            matches.push({ property: prop, value: value, matchType: 'exact', matchedText: value });
            continue; // exact is strongest, skip partial/keyword for this property
          }

          // 2) Keyword match: comma-separated terms checked individually
          if (value.indexOf(',') !== -1) {
            var terms = value.split(',');
            for (var ti = 0; ti < terms.length; ti++) {
              var term = terms[ti].trim().toLowerCase();
              if (term.length < 2) continue;
              if (lowerText.indexOf(term) !== -1) {
                matches.push({ property: prop, value: value, matchType: 'keyword', matchedText: terms[ti].trim() });
              }
            }
          } else {
            // 3) Partial match: individual words (3+ chars) from value found in text
            var words = lowerValue.split(/\s+/);
            for (var wi = 0; wi < words.length; wi++) {
              var word = words[wi].replace(/[^a-z0-9]/g, '');
              if (word.length < 3) continue;
              // Word boundary check
              var wordRegex = new RegExp('\\b' + word.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + '\\b', 'i');
              if (wordRegex.test(text)) {
                matches.push({ property: prop, value: value, matchType: 'partial', matchedText: word });
              }
            }
          }
        }

        if (matches.length > 0) {
          var label = parsed.getProperty(subj, 'rdfs:label') || subj.split(':').pop();
          results.push({ classId: subj, classLabel: label, matches: matches });
        }
      }

      return results;
    }

    function renderMatchEvidence(auditResults) {
      if (!auditResults || auditResults.length === 0) {
        return '<div class="result-card"><h3>Match Evidence Audit</h3>' +
          '<p style="color:#aaa;">No property-level matches found.</p></div>';
      }

      var html = '<div class="result-card">';
      html += '<h3>&#x1f50d; Match Evidence Audit</h3>';
      html += '<p style="color:#aaa;font-size:0.85em;margin-bottom:12px;">Shows which ontology property produced each match against the input text.</p>';

      for (var ci = 0; ci < auditResults.length; ci++) {
        var cls = auditResults[ci];
        html += '<div class="evidence-class-header">';
        html += escapeHtml(cls.classLabel);
        html += ' <span class="evidence-iri">' + escapeHtml(cls.classId) + '</span>';
        html += '</div>';

        html += '<table class="evidence-table">';
        html += '<thead><tr><th>Property</th><th>Value</th><th>Match Type</th><th>Matched Text</th></tr></thead>';
        html += '<tbody>';

        for (var mi = 0; mi < cls.matches.length; mi++) {
          var m = cls.matches[mi];
          var badgeClass = 'tag tag-' + m.matchType;
          html += '<tr>';
          html += '<td><code>' + escapeHtml(m.property) + '</code></td>';
          html += '<td>' + escapeHtml(truncateValue(m.value, 60)) + '</td>';
          html += '<td><span class="' + badgeClass + '">' + m.matchType + '</span></td>';
          html += '<td><strong>' + escapeHtml(m.matchedText) + '</strong></td>';
          html += '</tr>';
        }

        html += '</tbody></table>';
      }

      html += '</div>';
      return html;
    }

    function truncateValue(str, maxLen) {
      if (str.length <= maxLen) return str;
      return str.substring(0, maxLen) + '...';
    }

    // Load medical example by default
    window.addEventListener('load', function() {
      loadExample('medical');
    });
  </script>
</body>
</html>
